from __future__ import annotations
from datetime import datetime
from pathlib import Path
import re
from typing import Any

import pandas as pd

from .plinkio import read_typed_csv, IO_REGISTRY


TIME_FORMAT = "%a %b %d %H:%M:%S %Y"


def clean_plink_log(log: bytes) -> str:
    """Removes bytes from realtime progress updates present in the
    raw byte stream captured from stdout of a plink run."""
    log = re.sub(rb"(\d+%\x08+)+", b"", log)
    return log.decode("utf-8")


def get_time(text: str, kind: str) -> datetime | None:
    """Pull out the start or end time from plink log."""
    if kind not in ("start", "end"):
        raise ValueError(f"`kind` must be one of 'start' or 'end'.")
    p = kind.title() + r" time: ([\w+|\s+]+\d+ \d{2}:\d{2}:\d{2} \d{4})"
    match = re.search(p, text)
    if match:
        return datetime.strptime(match.group(1), TIME_FORMAT)
    return None


class InspectionView:
    def __init__(self, log: bytes, params: dict[str, Any] | None = None):
        """Represents the logging data of a plink run.

        Parameters
        ----------
        log : bytes
            The raw logging output from Plink, captured from stdout.

        params : dict, optional, default None
            Dictionary of parameters supplied to `Plink.run`

        Attributes
        ----------
        text : str
            Plain text of the plink log.

        params : dict
            Parameters used in the run represented.

        start : datetime
            The start time of the plink run.

        end : datetime
            The end time of the plink run.

        log : Path or None
            The path to the plink log file.


        files : dict
            Dictionary of files written by the plink process.

        """
        self.text = clean_plink_log(log)
        self.params = params

    def __str__(self) -> str:
        return self.text

    def __repr__(self) -> str:
        params = ""
        if self.params:
            params = ", ".join(f"{key}={val}" for key, val in self.params.items())
        return f"{self.__class__.__name__}({params})"

    @property
    def start(self) -> datetime | None:
        """Get start time of plink run."""
        return get_time(self.text, "start")

    @property
    def end(self) -> datetime | None:
        """Get end time of plink run."""
        return get_time(self.text, "end")

    @property
    def log(self) -> Path | None:
        """Get path to the plink log file."""
        match = re.search(r"Logging to (.*)\.\n", self.text)
        if match:
            return Path(match.group(1))
        return None

    @property
    def files(self) -> dict[str, Path] | None:
        """Get files generated by plink."""
        # TODO This would be better determined when parsing flags
        # passed to plink; using regex for now
        def _get_file_type(path: Path) -> str:
            suffixes = path.suffixes
            file_type = "".join(suffixes).replace(".", "_")
            return file_type[1:]

        if not self.params:
            return None

        out = self.params["out"]
        writes = re.findall(r"written to\s+(" + out + r"\.[\w+|\.]+)", self.text)
        writes += re.findall(r"Writing\s+(" + out + r"\.[\w+|\.]+)", self.text)
        file_paths = (Path(p) for p in writes)
        return {_get_file_type(p): p for p in file_paths}

    def read_file(self, file_name: str) -> pd.DataFrame:
        """Reads a file from its short file type name.

        Note, the files which can be read directly via this method are very
        limited at the moment. In the meantime use the `files` attribute
        along with `pandas`.

        Parameters
        ----------
        file_name : string
            Should be one of the keys present under the `files` attribute.

        Returns
        -------
        df : DataFrame
            The contents of the file as a dataframe.

        """
        if not self.files or file_name not in self.files:
            raise ValueError(
                f"No file of type '{file_name}' generated by this plink process."
            )
        if file_name not in IO_REGISTRY:
            raise NotImplementedError(
                f"Reading files of type '{file_name}' not implemented yet."
            )
        file = self.files[file_name]
        # TODO Plink's file .csv-like formats are quite involved, with columns
        # sometimes dependant on parameters passed to the flag indicating
        # plink should generate the file. To do this right, we will need to read
        # relevant info from self.params and incorporate that into parsing.
        return read_typed_csv(file, IO_REGISTRY[file_name], header=None, sep=r"\s+")
